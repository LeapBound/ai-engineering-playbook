# 实践成果展示：Lucy Orchestrator

## 为什么放这个案例

本项目强调“方法论必须可落地、可验证”。

`lucy-code` 不是概念演示，而是一个可运行的实践项目：
- 面向飞书的编码编排器（Feishu + OpenCode）
- 显式状态机驱动任务生命周期
- 具备隔离执行、可靠性与可观测性

这个案例用来回答一个核心问题：
**“方法论如何变成工程系统，而不是停留在文档里？”**

## 项目定位（实践侧）

参考项目：`~/git_home/lucy-code`

核心能力（来自实践项目 README 与代码结构）：
- 状态机流转：`NEW -> CLARIFYING -> WAIT_APPROVAL -> RUNNING -> TESTING -> DONE/FAILED`
- 飞书双通道接入：Webhook + LongConn（WebSocket）
- OpenCode 双驱动：SDK 默认 + CLI 兜底
- 任务级隔离：按任务创建 git worktree
- 可靠性机制：原子写、消息去重、草稿存储、历史清理
- 可观测性：结构化日志 + 指标统计（计数/耗时）

## 和本方法论的映射关系

### 1) 角色边界（Human vs AI）

方法论要求：人负责决策，AI 负责执行。

在实践项目中的体现：
- 明确审批关卡：澄清后进入 `WAIT_APPROVAL`，用户确认后才能执行
- 状态机显式限制非法流转，避免“跳过约束直接执行”

对应方法论章节：`docs/01-role-boundary.md`

### 2) 结构化输出

方法论要求：输出可校验、可复用、可沉淀。

在实践项目中的体现：
- 任务对象/计划步骤/事件日志均是结构化数据
- 产物按任务归档（plan、diff、test log、report），便于复盘与审计

对应方法论章节：`docs/02-structured-output.md`

### 3) Review 权限反转

方法论要求：优先审规则和流程，不是逐行追 AI 生成代码。

在实践项目中的体现：
- 先有状态机约束、策略检查、审批流程，再有运行动作
- 测试阶段与报告产物成为“可审计证据”，而不是口头说明

对应方法论章节：`docs/03-review-inversion.md`

### 4) 失败案例沉淀

方法论要求：从失败中提炼规则，形成可执行防线。

在实践项目中的体现：
- 错误路径有统一事件记录与指标
- 历史任务、测试报告、日志可以直接作为事故复盘素材

对应方法论章节：`docs/04-failure-cases.md`

## 可直接展示给团队的“成果清单”

- **流程成果**：需求接入 -> 澄清 -> 审批 -> 执行 -> 测试 -> 归档的闭环流程
- **工程成果**：状态机、策略层、运行时适配器、通道接入层等模块化代码结构
- **治理成果**：任务事件可追踪，执行证据可回放，失败可复盘
- **运维成果**：支持 Docker 隔离参数、任务存储清理、消息去重策略

## 对本网站的价值

这让本项目不只是“倡议书”，而是“有真实工程映射的治理方法论”：
- 文档提供原则
- 实践项目提供证据
- 两者形成可复制的落地路径

## 下一步建议（从展示走向标准化）

1. 增加“方法论 -> 实践实现点”的对照表（每条原则对应代码模块）
2. 增加“最小复现路径”（30 分钟跑通 demo）
3. 增加“治理指标看板定义”（审批等待时长、失败率、自动修复率等）
